/**
 * üß† MOTEUR DE RAISONNEMENT AVANC√â
 * Analyse, inf√®re et raisonne avant de g√©n√©rer une r√©ponse
 */

const fs = require('fs');
const path = require('path');

const REASONING_CACHE_FILE = path.join(__dirname, 'data', 'reasoning-cache.json');

// Cache des raisonnements pour apprentissage
let reasoningCache = {
    patterns: [],           // Patterns de raisonnement r√©ussis
    inferences: [],         // Inf√©rences faites
    logicalChains: [],      // Cha√Ænes de raisonnement
    conceptMap: {}          // Carte conceptuelle (relations entre concepts)
};

// Charger le cache
function loadReasoningCache() {
    try {
        if (fs.existsSync(REASONING_CACHE_FILE)) {
            reasoningCache = JSON.parse(fs.readFileSync(REASONING_CACHE_FILE, 'utf8'));
            console.log('üß† Cache de raisonnement charg√©');
        }
    } catch (error) {
        console.error('‚ùå Erreur chargement cache raisonnement:', error.message);
    }
}

// Sauvegarder le cache
function saveReasoningCache() {
    try {
        fs.writeFileSync(REASONING_CACHE_FILE, JSON.stringify(reasoningCache, null, 2));
    } catch (error) {
        console.error('‚ùå Erreur sauvegarde cache raisonnement:', error.message);
    }
}

/**
 * üéØ D√âTECTION D'INTENTION
 * Comprend ce que l'utilisateur veut vraiment
 */
function detectIntent(message) {
    const lowerMsg = message.toLowerCase();
    const intent = {
        type: 'unknown',
        subtype: null,
        confidence: 0,
        keywords: [],
        requiresReasoning: false,
        complexity: 'simple'
    };

    // Questions explicites
    if (message.includes('?')) {
        intent.type = 'question';
        
        // Questions complexes n√©cessitant raisonnement
        if (lowerMsg.match(/pourquoi|comment (faire|√ßa marche|fonctionne)|explique|quelle diff√©rence|qu'est-ce que/)) {
            intent.subtype = 'explanation';
            intent.requiresReasoning = true;
            intent.complexity = 'complex';
            intent.confidence = 0.9;
        }
        // Questions d'opinion/conseil
        else if (lowerMsg.match(/tu penses|avis|conseil|recommand|sugg√®re|meilleur|pr√©f√©rable/)) {
            intent.subtype = 'advice';
            intent.requiresReasoning = true;
            intent.complexity = 'medium';
            intent.confidence = 0.85;
        }
        // ‚ö†Ô∏è CHOIX SIMPLE A ou B - DOIT √äTRE TEST√â AVANT "comparison" !
        // Ex: "homme ou femme ?", "oui ou non dcp ?", "A ou B donc ?"
        else if (lowerMsg.match(/^[\w\s]{1,20}\s+ou\s+[\w\s]{1,20}(\s*(dcp|donc|alors|,|\?)\s*)?$/)) {
            intent.subtype = 'choice';
            intent.requiresReasoning = false;
            intent.complexity = 'simple';
            intent.confidence = 0.9;
        }
        // Questions de comparaison (vraies comparaisons complexes)
        else if (lowerMsg.match(/diff√©rence entre|comparer|versus|vs|plut√¥t|mieux que/)) {
            intent.subtype = 'comparison';
            intent.requiresReasoning = true;
            intent.complexity = 'medium';
            intent.confidence = 0.8;
        }
        // Questions causales
        else if (lowerMsg.match(/cause|raison|pourquoi|comment se fait|d'o√π vient/)) {
            intent.subtype = 'causal';
            intent.requiresReasoning = true;
            intent.complexity = 'complex';
            intent.confidence = 0.9;
        }
        // Questions simples (fait, oui/non)
        else {
            intent.subtype = 'factual';
            intent.complexity = 'simple';
            intent.confidence = 0.7;
        }
    }
    // Demandes d'action
    else if (lowerMsg.match(/^(peux-tu|pourrais-tu|fais|fait|aide|aide-moi|explique|raconte|donne|trouve|cherche)/)) {
        intent.type = 'request';
        intent.subtype = 'action';
        intent.requiresReasoning = lowerMsg.match(/explique|analyse|compare|trouve/) !== null;
        intent.complexity = intent.requiresReasoning ? 'medium' : 'simple';
        intent.confidence = 0.8;
    }
    // Affirmations avec implication (besoin de valider/inf√©rer)
    else if (lowerMsg.match(/je pense que|selon moi|√† mon avis|il me semble|peut-√™tre|probablement/)) {
        intent.type = 'statement';
        intent.subtype = 'opinion';
        intent.requiresReasoning = true;
        intent.complexity = 'medium';
        intent.confidence = 0.75;
    }
    // Probl√®mes/plaintes
    else if (lowerMsg.match(/probl√®me|bug|marche pas|fonctionne pas|erreur|aide|bloqu√©|comprends pas/)) {
        intent.type = 'problem';
        intent.subtype = 'troubleshooting';
        intent.requiresReasoning = true;
        intent.complexity = 'complex';
        intent.confidence = 0.85;
    }
    // D√©clarations simples
    else {
        intent.type = 'statement';
        intent.subtype = 'simple';
        intent.complexity = 'simple';
        intent.confidence = 0.6;
    }

    // Extraire les mots-cl√©s importants
    const keywords = message.match(/\b[a-z√†√¢√§√©√®√™√´√Ø√Æ√¥√π√ª√º√ø≈ì√¶√ß]{4,}\b/gi) || [];
    intent.keywords = [...new Set(keywords.slice(0, 5))]; // 5 mots-cl√©s uniques max

    return intent;
}

/**
 * üîó INF√âRENCE ET D√âDUCTION
 * Fait des d√©ductions logiques bas√©es sur le contexte
 */
function makeInferences(message, userProfile, smartMemory) {
    const inferences = {
        implicit_needs: [],      // Besoins implicites d√©tect√©s
        assumptions: [],         // Hypoth√®ses sur le contexte
        related_topics: [],      // Sujets connexes pertinents
        user_state: null,        // √âtat probable de l'utilisateur
        next_likely_topic: null, // Sujet probable suivant
        contradictions: []       // üÜï Contradictions d√©tect√©es avec la m√©moire
    };

    const lowerMsg = message.toLowerCase();

    // üÜï V√âRIFIER LES CONTRADICTIONS avec la m√©moire existante
    if (smartMemory && smartMemory.identity && smartMemory.identity.facts) {
        for (const fact of smartMemory.identity.facts) {
            const lowerFact = fact.toLowerCase();
            
            // V√©rifier les contradictions de genre
            if (lowerFact.includes('je suis un mec') || lowerFact.includes('je suis un homme') || lowerFact.includes('homme')) {
                // D√©tection √©tendue des mentions f√©minines
                if (lowerMsg.match(/une fille|une femme|pr√©nom de fille|pr√©nom f√©minin|pr√©nom de femme|f√©minin/)) {
                    inferences.contradictions.push({
                        type: 'gender',
                        memorized: fact,
                        current: message,
                        warning: 'ATTENTION: La m√©moire indique que cet utilisateur est un homme. Ne PAS le traiter comme une femme.'
                    });
                }
            }
            // V√©rifier aussi l'inverse (si m√©moris√© comme femme)
            else if (lowerFact.includes('je suis une fille') || lowerFact.includes('je suis une femme') || lowerFact.includes('femme')) {
                if (lowerMsg.match(/un mec|un homme|masculin|pr√©nom masculin/)) {
                    inferences.contradictions.push({
                        type: 'gender',
                        memorized: fact,
                        current: message,
                        warning: 'ATTENTION: La m√©moire indique que cet utilisateur est une femme. Ne PAS le traiter comme un homme.'
                    });
                }
            }
            
            // V√©rifier les contradictions d'identit√©
            if (lowerFact.match(/je m'appelle|mon pr√©nom|je suis [A-Z]/)) {
                // Extraire le pr√©nom m√©moris√© si possible
                const nameMatch = lowerFact.match(/je m'appelle (\w+)|mon pr√©nom (?:est|c'est) (\w+)/i);
                if (nameMatch) {
                    const memorizedName = nameMatch[1] || nameMatch[2];
                    inferences.assumptions.push(`User's name is ${memorizedName} (from memory)`);
                }
            }
        }
    }

    // Inf√©rer les besoins implicites
    if (lowerMsg.match(/comment|aide|explique/)) {
        inferences.implicit_needs.push('need_explanation');
    }
    if (lowerMsg.match(/probl√®me|marche pas|erreur/)) {
        inferences.implicit_needs.push('need_solution');
        inferences.implicit_needs.push('need_support');
    }
    if (lowerMsg.match(/tu penses|avis|conseil/)) {
        inferences.implicit_needs.push('need_opinion');
        inferences.implicit_needs.push('need_validation');
    }

    // Inf√©rer l'√©tat de l'utilisateur bas√© sur le langage
    if (lowerMsg.match(/putain|bordel|chiant|nul/)) {
        inferences.user_state = 'frustrated';
        inferences.assumptions.push('User is experiencing frustration, may need calmer approach');
    } else if (lowerMsg.match(/g√©nial|super|cool|merci|top/)) {
        inferences.user_state = 'positive';
        inferences.assumptions.push('User is satisfied, can be more casual');
    } else if (lowerMsg.match(/triste|dur|difficile|mal/)) {
        inferences.user_state = 'negative';
        inferences.assumptions.push('User may need emotional support');
    } else if (lowerMsg.match(/\?{2,}|!!!|aide/)) {
        inferences.user_state = 'confused_or_urgent';
        inferences.assumptions.push('User needs clear, direct answer');
    } else {
        inferences.user_state = 'neutral';
    }

    // Relier aux sujets du profil utilisateur
    if (smartMemory && smartMemory.knowledge && smartMemory.knowledge.interests) {
        const msgWords = lowerMsg.split(/\s+/);
        for (const interest of smartMemory.knowledge.interests) {
            if (msgWords.some(word => interest.toLowerCase().includes(word))) {
                inferences.related_topics.push(interest);
            }
        }
    }

    // D√©tecter les topics connexes par association conceptuelle
    const conceptAssociations = {
        'code': ['programmation', 'bug', 'd√©veloppement', 'tech'],
        'jeu': ['gaming', 'console', 'pc', 'fps'],
        'musique': ['√©couter', 'concert', 'album', 'artiste'],
        'film': ['s√©rie', 'netflix', 'cin√©ma', 'regarder'],
        'probl√®me': ['solution', 'aide', 'r√©soudre', 'fix']
    };

    for (const [concept, related] of Object.entries(conceptAssociations)) {
        if (lowerMsg.includes(concept)) {
            inferences.related_topics.push(...related.filter(r => !inferences.related_topics.includes(r)));
        }
    }

    return inferences;
}

/**
 * üß© D√âCOMPOSITION DE PROBL√àME
 * D√©compose les questions complexes en sous-questions
 */
function decomposeQuestion(message, intent) {
    if (!intent.requiresReasoning) {
        return { subQuestions: [], needsDecomposition: false };
    }

    const decomposition = {
        mainQuestion: message,
        subQuestions: [],
        reasoningSteps: [],
        needsDecomposition: true
    };

    const lowerMsg = message.toLowerCase();

    // Questions "comment"
    if (lowerMsg.includes('comment')) {
        decomposition.subQuestions.push('Quel est le contexte ?');
        decomposition.subQuestions.push('Quelles sont les √©tapes ?');
        decomposition.subQuestions.push('Quels sont les pr√©requis ?');
        decomposition.reasoningSteps.push('1. Identifier le contexte');
        decomposition.reasoningSteps.push('2. Lister les √©tapes s√©quentiellement');
        decomposition.reasoningSteps.push('3. Mentionner les points d\'attention');
    }
    // Questions "pourquoi"
    else if (lowerMsg.includes('pourquoi')) {
        decomposition.subQuestions.push('Quelle est la cause ?');
        decomposition.subQuestions.push('Quelles sont les cons√©quences ?');
        decomposition.subQuestions.push('Y a-t-il des alternatives ?');
        decomposition.reasoningSteps.push('1. Identifier la cause principale');
        decomposition.reasoningSteps.push('2. Expliquer le m√©canisme causal');
        decomposition.reasoningSteps.push('3. Contextualiser avec exemples');
    }
    // Comparaisons
    else if (lowerMsg.match(/ou|versus|vs|mieux|plut√¥t|diff√©rence entre/)) {
        decomposition.subQuestions.push('Quels sont les crit√®res de comparaison ?');
        decomposition.subQuestions.push('Avantages de chaque option ?');
        decomposition.subQuestions.push('Inconv√©nients de chaque option ?');
        decomposition.reasoningSteps.push('1. Lister les options');
        decomposition.reasoningSteps.push('2. Comparer sur crit√®res cl√©s');
        decomposition.reasoningSteps.push('3. Donner une recommandation bas√©e sur le contexte');
    }
    // Demandes de conseil
    else if (lowerMsg.match(/conseil|recommand|sugg√®re|avis/)) {
        decomposition.subQuestions.push('Quel est le contexte/objectif ?');
        decomposition.subQuestions.push('Quelles sont les contraintes ?');
        decomposition.subQuestions.push('Quelle est la meilleure approche ?');
        decomposition.reasoningSteps.push('1. Comprendre l\'objectif');
        decomposition.reasoningSteps.push('2. √âvaluer les options');
        decomposition.reasoningSteps.push('3. Recommander avec justification');
    }
    // Probl√®mes/troubleshooting
    else if (lowerMsg.match(/probl√®me|bug|marche pas|erreur/)) {
        decomposition.subQuestions.push('Quel est le sympt√¥me exact ?');
        decomposition.subQuestions.push('Quelles sont les causes possibles ?');
        decomposition.subQuestions.push('Quelles sont les solutions ?');
        decomposition.reasoningSteps.push('1. Diagnostiquer le probl√®me');
        decomposition.reasoningSteps.push('2. Identifier les causes probables');
        decomposition.reasoningSteps.push('3. Proposer solutions ordonn√©es par probabilit√©');
    }

    return decomposition;
}

/**
 * üéì G√âN√âRATION DE CONTEXTE DE RAISONNEMENT
 * Cr√©e un prompt enrichi pour guider l'IA vers un raisonnement structur√©
 */
function buildReasoningContext(message, intent, inferences, decomposition, userProfile) {
    let reasoningPrompt = '\n\nüß† CONTEXTE DE RAISONNEMENT:\n';

    // üÜï AVERTISSEMENT CRITIQUE SI CONTRADICTIONS D√âTECT√âES
    if (inferences.contradictions && inferences.contradictions.length > 0) {
        reasoningPrompt += `\n‚õî CONTRADICTIONS D√âTECT√âES - LECTURE OBLIGATOIRE:\n`;
        for (const contradiction of inferences.contradictions) {
            reasoningPrompt += `   ‚ö†Ô∏è ${contradiction.warning}\n`;
            reasoningPrompt += `   üìù M√©moire: "${contradiction.memorized}"\n`;
            reasoningPrompt += `   ‚ùå Ne PAS assumer le contraire de ce fait m√©moris√©.\n`;
        }
        reasoningPrompt += `\n`;
    }

    // üÜï GESTION SP√âCIALE POUR LES CHOIX SIMPLES
    if (intent.subtype === 'choice') {
        reasoningPrompt += `üìã Type de question: CHOIX SIMPLE\n`;
        reasoningPrompt += `üí° INSTRUCTIONS STRICTES:\n`;
        reasoningPrompt += `   - Regarde l'HISTORIQUE de conversation et la M√âMOIRE utilisateur\n`;
        reasoningPrompt += `   - Si l'info est dans la m√©moire ou l'historique, r√©ponds DIRECTEMENT avec le fait\n`;
        reasoningPrompt += `   - NE DIS JAMAIS "je ne sais pas" si tu peux d√©duire du contexte\n`;
        reasoningPrompt += `   - Format: Une phrase courte et directe\n`;
        reasoningPrompt += `   - Exemple: "T'es un mec" ou "Tu as 25 ans" (pas de "je pense que..." ou "il est possible")\n\n`;
        return reasoningPrompt;
    }

    // 1. Intention d√©tect√©e
    reasoningPrompt += `- Type: ${intent.type}`;
    if (intent.subtype) {
        reasoningPrompt += ` (${intent.subtype})`;
    }
    reasoningPrompt += `\n- Complexit√©: ${intent.complexity}\n`;

    // 2. Besoins implicites
    if (inferences.implicit_needs.length > 0) {
        reasoningPrompt += `- Besoins d√©tect√©s: ${inferences.implicit_needs.join(', ')}\n`;
    }

    // 3. √âtat de l'utilisateur
    if (inferences.user_state && inferences.user_state !== 'neutral') {
        reasoningPrompt += `- √âtat utilisateur: ${inferences.user_state}\n`;
    }
    
    // üÜï 3.5. Instructions sp√©ciales pour questions factuelles simples
    if (intent.subtype === 'factual' && intent.complexity === 'simple') {
        reasoningPrompt += `\nüí° R√âPONSE FACTUELLE ATTENDUE:\n`;
        reasoningPrompt += `   - Consulte la m√©moire utilisateur et l'historique\n`;
        reasoningPrompt += `   - Si l'info existe, r√©ponds avec CERTITUDE (pas "peut-√™tre", "possible")\n`;
        reasoningPrompt += `   - Si l'info n'existe PAS, demande ou d√©duis du contexte\n`;
        reasoningPrompt += `   - Sois direct et affirmatif\n\n`;
    }

    // 4. D√©composition si n√©cessaire
    if (decomposition.needsDecomposition && decomposition.reasoningSteps.length > 0) {
        reasoningPrompt += `\nüìã √âTAPES DE RAISONNEMENT √Ä SUIVRE:\n`;
        for (const step of decomposition.reasoningSteps) {
            reasoningPrompt += `   ${step}\n`;
        }
    }

    // 5. Sujets connexes
    if (inferences.related_topics.length > 0) {
        reasoningPrompt += `\nüîó Concepts li√©s: ${inferences.related_topics.slice(0, 5).join(', ')}\n`;
    }

    // 6. Directives de r√©ponse bas√©es sur l'analyse
    reasoningPrompt += `\nüí° DIRECTIVES DE R√âPONSE:\n`;
    
    if (intent.complexity === 'complex') {
        reasoningPrompt += `   - Structurer la r√©ponse en √©tapes claires\n`;
        reasoningPrompt += `   - Expliquer le raisonnement sous-jacent\n`;
    }
    
    if (inferences.user_state === 'frustrated') {
        reasoningPrompt += `   - Rester calme et constructif\n`;
        reasoningPrompt += `   - Proposer des solutions concr√®tes\n`;
    } else if (inferences.user_state === 'confused_or_urgent') {
        reasoningPrompt += `   - √ätre direct et clair\n`;
        reasoningPrompt += `   - √âviter les d√©tails superflus\n`;
    } else if (inferences.user_state === 'positive') {
        reasoningPrompt += `   - Maintenir le ton positif\n`;
        reasoningPrompt += `   - Peut √™tre plus d√©contract√©\n`;
    }

    if (intent.subtype === 'comparison') {
        reasoningPrompt += `   - Pr√©senter les options de mani√®re √©quilibr√©e\n`;
        reasoningPrompt += `   - Donner une recommandation finale\n`;
    }

    if (intent.type === 'problem') {
        reasoningPrompt += `   - Proposer des solutions concr√®tes et testables\n`;
        reasoningPrompt += `   - Prioriser par probabilit√© de succ√®s\n`;
    }

    reasoningPrompt += `\n‚ö†Ô∏è IMPORTANT: Raisonne avant de r√©pondre. Ta r√©ponse doit montrer que tu as analys√© la question en profondeur.\n`;

    return reasoningPrompt;
}

/**
 * üöÄ FONCTION PRINCIPALE: Analyser et enrichir le message
 */
function analyzeAndReason(message, userProfile = null, smartMemory = null) {
    console.log(`\nüß† === D√âBUT ANALYSE RAISONNEMENT ===`);
    console.log(`üìù Message: "${message.substring(0, 80)}..."`);

    // 1. D√©tecter l'intention
    const intent = detectIntent(message);
    console.log(`üéØ Intention: ${intent.type} (${intent.subtype || 'none'}) - Complexit√©: ${intent.complexity}`);

    // 2. Faire des inf√©rences
    const inferences = makeInferences(message, userProfile, smartMemory);
    console.log(`üîç Inf√©rences: √âtat=${inferences.user_state}, Besoins=${inferences.implicit_needs.length}`);
    
    // üÜï Logger les contradictions si d√©tect√©es
    if (inferences.contradictions && inferences.contradictions.length > 0) {
        console.log(`‚õî CONTRADICTIONS D√âTECT√âES: ${inferences.contradictions.length}`);
        for (const contradiction of inferences.contradictions) {
            console.log(`   ‚ö†Ô∏è ${contradiction.type}: ${contradiction.warning}`);
        }
    }

    // 3. D√©composer si n√©cessaire
    const decomposition = decomposeQuestion(message, intent);
    if (decomposition.needsDecomposition) {
        console.log(`üß© D√©composition: ${decomposition.subQuestions.length} sous-questions`);
    }

    // 4. Construire le contexte de raisonnement
    const reasoningContext = buildReasoningContext(message, intent, inferences, decomposition, userProfile);

    // 5. Sauvegarder le pattern de raisonnement pour apprentissage
    if (intent.requiresReasoning) {
        reasoningCache.patterns.push({
            timestamp: new Date().toISOString(),
            message: message.substring(0, 100),
            intent: intent.type + '/' + intent.subtype,
            complexity: intent.complexity,
            user_state: inferences.user_state
        });

        // Garder seulement les 100 derniers patterns
        if (reasoningCache.patterns.length > 100) {
            reasoningCache.patterns = reasoningCache.patterns.slice(-100);
        }

        saveReasoningCache();
    }

    console.log(`‚úÖ Contexte de raisonnement g√©n√©r√© (${reasoningContext.length} caract√®res)`);
    console.log(`üß† === FIN ANALYSE RAISONNEMENT ===\n`);

    return {
        intent,
        inferences,
        decomposition,
        reasoningContext,
        shouldUseAdvancedReasoning: intent.requiresReasoning || intent.complexity !== 'simple'
    };
}

/**
 * üìä STATISTIQUES DE RAISONNEMENT
 */
function getReasoningStats() {
    const stats = {
        totalPatterns: reasoningCache.patterns.length,
        complexityDistribution: {},
        intentDistribution: {},
        recentPatterns: reasoningCache.patterns.slice(-10)
    };

    for (const pattern of reasoningCache.patterns) {
        // Distribution par complexit√©
        stats.complexityDistribution[pattern.complexity] = 
            (stats.complexityDistribution[pattern.complexity] || 0) + 1;
        
        // Distribution par intention
        stats.intentDistribution[pattern.intent] = 
            (stats.intentDistribution[pattern.intent] || 0) + 1;
    }

    return stats;
}

// Initialisation
loadReasoningCache();

module.exports = {
    analyzeAndReason,
    detectIntent,
    makeInferences,
    decomposeQuestion,
    buildReasoningContext,
    getReasoningStats
};
